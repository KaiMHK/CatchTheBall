
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;
phMaterial material;
phMaterial materialback;
phMaterial materialred;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 22;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "1.bmp",
    "2.bmp",
    "3.bmp",
    "4.bmp",
    "5.bmp",
    "6.bmp",
    "7.bmp",
    "8.bmp",
    "9.bmp",
    "10.bmp",
    "11.bmp",
    "12.bmp",
    "13.bmp",
    "14.bmp",
    "15.bmp",
    "woodfloor.bmp",//15
    "luxwall1.bmp",
    "luxwall2.bmp",//17
    "luxwall3.bmp",
    "luxwall4.bmp",//19
    "basketball.bmp",
    "color.bmp",//21
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.75); 



// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 3;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;            // RESERVED FOR USE BY 155A PROJECT

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

int x = 0;



// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.8, 0.8, 0.8);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    material.SpecularColor.Set(0.9, 0.9, 0.9);
    material.AmbientColor.Set(0.3, 0.3, 0.3);
    material.DiffuseColor.Set(1, 1, 1);       
    material.SpecularExponent = 40.0;

    materialback.SpecularColor.Set(0.9, 0.9, 0.9);
    materialback.AmbientColor.Set(0.3, 0.3, 0.3);
    materialback.DiffuseColor.Set(0, 1, 0);
    materialback.SpecularExponent = 40.0;

    materialred.SpecularColor.Set(0.9, 0.9, 0.9);
    materialred.AmbientColor.Set(0.3, 0.3, 0.3);
    materialred.DiffuseColor.Set(1, 0, 0);
    materialred.SpecularExponent = 40.0;
    

    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         5.0f, 0.0f, -5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         5.0f, 0.0f,  5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -5.0f, 0.0f,  5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    float WallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Back left
         5.0f, 0.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Back right
        -5.0f, 8.0f, -5.0f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Front right
         5.0f, 8.0f, -5.0f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Front left
    };
    unsigned int WallElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(WallVerts), WallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(WallElts), WallElts, GL_STATIC_DRAW);

    // For the circular surface:
    // Allocate the needed VAO, VBO< EBO
    // The normal vectors is specified separately for each vertex. (It is not a generic attribute.)
    // YOU MUST MODIFY THIS TO (A) USE STRIDES OF 8 *sizeof(float), (B) COMMENT IN THE LINES FOR vertTexCoords 
    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	// Store vertices in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); // Store normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                 // Enabled the stored normals (so they are not generic)
    // ONCE YOU HAVE TEXTURE COORDINATES WORKING FOR THE CIRCULAR SURFACE,
    //   PUT THE NEXT TWO LINES BACK IN, AND CHANGE THE STRIDE FACTOR TO "8" IN THE PREVIOUS CALLS TO glVertexAttribPointer.
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices

    // No data has been loaded into the VBO's for the circular surface yet.
    // This is done by the "SamsRemeshCircularSurf" routine.

    MyRemeshCircularSurf();

    // FOR THE BACK WALL: ADD YOUR OWN CODE!! 
    // IT WILL BE SIMILAR TO THE FLOOR ABOVE.
    // YOU DO NOT NEED TO REMESH THE BACK WALL - ONE RECTANGLE (TWO TRIANGLES) IS ENOUGH

    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    MyRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes );

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************
bool hit = false;
bool warn = false;
int flashcount = 0;
int warncount = 0;

void MyRenderGeometries() {

    if ((currentTime > 0.99) && (x > pos - 1) && (x < pos + 1)) {
        score++;
        hit = true;
        flashcount = 8;
        cout << score << endl;

    }
    else if ((currentTime > 0.99) && !((x > pos - 1) && (x < pos + 1))) {
        cout << "miss" << endl;
        score = (score>0) ? score-1:0;
        warncount = 8;
    }
    else {
        hit = false;
        flashcount = (flashcount > 0) ? flashcount - 1 : 0;
        warncount = (warncount > 0) ? warncount - 1 : 0;
    }

    

    float matEntries[16];       // Temporary storage for floats


    // Render the Floor 

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);  
    glBindTexture(GL_TEXTURE_2D, TextureNames[16]);
    //selectShaderProgram(shaderProgramProc);
    material.LoadIntoShaders();
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();
    if (renderFloorOnly) {
        return;
    }


    // Render the circular surface

    selectShaderProgram(shaderProgramBitmap);
    SamsRenderCircularSurf();


    // Render the back wall
 
    LinearMapR4 back = viewMatrix;
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall]);                // Select the floor VAO (Vertex Array Object)
    
    if (flashcount>0) materialback.LoadIntoShaders();
    else if(warncount>0) materialred.LoadIntoShaders();         // Use the bright underlying color
    else materialUnderTexture.LoadIntoShaders();

    back.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    int tx = 0;
    if (score < 15)  tx = score;
    else tx = 14;
    glBindTexture(GL_TEXTURE_2D, TextureNames[tx]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    
    back.Mult_glRotate(PI/2,0,-1,0);
    back.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    materialUnderTexture.LoadIntoShaders();
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    back.Mult_glRotate(PI, 0, 1, 0);
    back.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    materialUnderTexture.LoadIntoShaders();
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    
    
    // Basket

    LinearMapR4 matDemo = viewMatrix;
    //cout << pos << endl;
    matDemo.Mult_glTranslate(pos, 1.1, 4.0);
    //matDemo.Mult_glRotate(PI / 2, 1, 0, 0);
    matDemo.Mult_glScale(1, 0.1, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);
    glUniform1i(applyTextureLocation, true);             
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);
    check_for_opengl_errors();      // Watch the console window for error messages!


}



void SamsRenderCircularSurf()
{
    float matEntries[16];       // Temporary storage for floats
    int random = (rand() % 7) - 3.5;

    glBindVertexArray(myVAO[iCircularSurf]);

    // Calculate the model view matrix for the circular surface
    LinearMapR4 matDemo = viewMatrix;
    if (currentTime < 0.001)  x = random;
    matDemo.Mult_glTranslate(x, 2, -3.5);     // Center in the back & raise up
    matDemo.Mult_glRotate(PI / 4, 1, 0, 0);
    matDemo.Mult_glScale(0.12, 0.2, 0.12);         // Adjust the circular diameter and height

                                                 // Set the uniform values (they are not stored with the VAO and thus must be set again everytime
    materialUnderTexture.LoadIntoShaders();                       // Use the bright underlying material
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries); // Select the modelview matrix to place it
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose Mandala texture
    
    glUniform1i(applyTextureLocation, true);        // Enable applying the texture!
                                                                   // Draw the the triangle strips
    for (int i = 0; i < meshRes; i++) {
        glDrawElements(GL_TRIANGLE_STRIP, 1 + 2 * meshRes, GL_UNSIGNED_INT,
            (void*)(i * (1 + 2 * meshRes) * sizeof(unsigned int)));
    }
    glUniform1i(applyTextureLocation, false);           // Disable applying the texture!

    // Ball
    
    LinearMapR4 ball = viewMatrix;
    float Z_Animation = currentTime*10-5;
    material.LoadIntoShaders();
    if(currentTime < 0.001)  x = random;
    ball.Mult_glTranslate(x,5*cos(PI*(2.5-currentTime)), Z_Animation-0.5);
    ball.Mult_glScale(0.8);
    ball.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texSphere.Render();

    
}



// *******
// ADD TEXTURE COORDINATES TO  "MyRemeshCircularSurf" 


void MyRemeshCircularSurf()
{
    float r = PI4;
    float each_r = r / meshRes;
    float angle = PI2 / meshRes;
    int numsurfverts = 3 * (meshRes + 1);
    float height = 0;


    float* surfverts = new float[8 * ((meshRes)*meshRes + 1)];

    for (int cir = 0; cir < meshRes; cir++) {
        float cur_angle = 0.00f;
        for (int i = (cir * meshRes * 8); i + 7 < (8 * (cir + 1) * meshRes) + 8; i += 8) {

            surfverts[i] = r * cos(cur_angle);
            surfverts[i + 2] = -r * sin(cur_angle);

            if (cur_angle == 0.00f) {
                float x = r;
                height = 1 + (1 + 0.08 * x * x) * sin(x) / x;
            }
            float R = sinf(r) * (0.08 - (1 / (r * r))) + cosf(r) * ((1 / r) + (0.08 * r));
            surfverts[i + 1] = height;
            surfverts[i + 3] = -R * cos(cur_angle);
            surfverts[i + 4] = 1;
            surfverts[i + 5] = R * sin(cur_angle);
            
            //if (surfverts[i] == 0) surfverts[i + 6] = 0.5;
             surfverts[i + 6] = (surfverts[i]+12.5664)/(2*12.5664);
            
            //if (surfverts[i+2] == 0) surfverts[i + 7] = 0.5;
             surfverts[i + 7] = (surfverts[i+2]+12.5664)/(2 * 12.5664);

            cur_angle = cur_angle + angle;
        }
        r = r - each_r;
    }

    int last = 8 * meshRes * meshRes + 7;
    surfverts[last - 7] = 0;
    surfverts[last - 6] = 2;
    surfverts[last - 5] = 0;
    surfverts[last - 4] = 1;
    surfverts[last - 3] = 0;
    surfverts[last - 2] = 0.5;
    surfverts[last - 1] = 0.5;
    surfverts[last] = 0;

    unsigned int* surfelements = new unsigned int[meshRes * meshRes * 2 + meshRes];
    int piece = 0;
    int bias = 0;

    for (int j = 0; j < meshRes; j++) {
        int floor = 0;
        for (int i = piece * meshRes * 2 + bias; i < meshRes * 2 * (piece + 1) + bias; i += 2) {
            surfelements[i] = floor * meshRes + piece;
            surfelements[i + 1] = surfelements[i] + 1;
            for (int n = 0; n < meshRes + 1; n++) {
                if (surfelements[i + 1] == n * meshRes)surfelements[i + 1] = (n - 1) * meshRes;
            }
            floor++;
        }
        surfelements[meshRes * 2 * (piece + 1) + bias] = meshRes * meshRes;
        bias++;
        piece++;
    }
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[1]);
    glBufferData(GL_ARRAY_BUFFER, 8 * (meshRes * meshRes + 1) * sizeof(float), surfverts, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, (2 * meshRes * meshRes + meshRes) * sizeof(float), surfelements, GL_STATIC_DRAW);
}

